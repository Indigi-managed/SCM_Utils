# SCM_Utils is a library of utilities for the Space Cows Project
# 
# MIT License
# 
# Copyright (c) 2023 eResearch Centre, James Cook University
# Author: NigelB
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

# This file has been automatically generated by BitPacker.
# DO NOT EDIT IT or your changes will be overwritten.

from enum import Enum
from queue import Empty
from decimal import Decimal
from collections import OrderedDict

import re


SCM_DF_TRANSMISSION_ID_SIZE = 4
SCM_DF_TRANSMISSION_CRC16_SIZE = 16
SCM_DF_TRANSMISSION_SF_SIZE = 3
SCM_DF_TRANSMISSION_MC_SIZE = 9
SCM_DF_TRANSMISSION_PACKET_TYPE_SIZE = 5
SCM_DF_TRACKING_FLAGS_SIZE = 4
SCM_DF_TRACKING_TIMESLOT_SIZE = 4
SCM_DF_TRACKING_LONGITUDE_SIZE = 22
SCM_DF_TRACKING_LATITUDE_SIZE = 21
SCM_DF_TRACKING_ORIENTATION_SIZE = 3
SCM_DF_TRACKING_ACTIVITY_SIZE = 8
SCM_DF_TRACKING_BATTERY_SIZE = 5
SCM_DF_TRACKING_TEMP_MIN_SIZE = 6
SCM_DF_TRACKING_TEMP_MAX_SIZE = 6
SCM_DF_TRACKING_TEMP_ALERT_SIZE = 1
SCM_DF_POINT_DELTA_KM_SIZE = 6
SCM_DF_POINT_DELTA_M_SIZE = 7
SCM_DF_POINT_DELTA_ANGLE_SIZE = 11
SCM_DF_POINT_ACTIVITY_SIZE = 8
SCM_DF_POINT_TEMP_ALERT_SIZE = 1
SCM_DF_TRANSMISSION_BCH32_SIZE = 32

# SCM_DF Constants
SCM_DF_BUF_SIZE = 31
SCM_DF_TRANSMISSION_RECORDS = 4
SCM_DF_TEMP_MAX_HIGH = Decimal('52.0')
SCM_DF_TEMP_MAX_LOW = Decimal('20.0')
SCM_DF_TEMP_MIN_HIGH = Decimal('32.0')
SCM_DF_TEMP_MIN_LOW = Decimal('0.0')
SCM_DF_BAT_RANGE_HIGH = Decimal('4.6')
SCM_DF_BAT_RANGE_LOW = Decimal('3.0')


class DecodeError(Exception): pass
class EncodeError(Exception): pass


class BitQueue:
    def __init__(self, source=""):
        self.source = source
        if source.startswith("0x") or source.startswith("0X"):
            self.source = source[2::]
        if ' ' in self.source:
            self.source = self.source.replace(" ", '')
        self.data = None
        self.reset()

    def reset(self):
        if len(self.source) == 0:
            self.data = ""
            return
        result = ""            
        data = bytes.fromhex(self.source)
        for i in data:
            result = "{}{}".format(result, bin(i)[2:].zfill(8))
        self.data = result

    def pop(self, count):
        if self.size() == 0: raise Empty()
        result = self.data[:count]
        self.data = self.data[count:]
        return result

    def size(self):
        return len(self.data)

    def clear(self):
        self.data = ""

    def __push(self, bits):
        symbols = {x:'' for x in bits}
        _valid_symbols = {k:v for k, v in symbols.items() if k in [0, 1, '0', '1']}
        if len(_valid_symbols.keys()) != len(symbols.keys()):
            raise Exception("Invalid Symbols")
        self.data = "{}{}".format(self.data, bits)
    
    def push(self, value, bits):
        if hasattr(value, '__dict__') and isinstance(value, Enum):
            value = value.value    
        v = bin(value & int('1'*bits, 2))[2:]
        self.__push(v.zfill(bits))
    
    def get_bytes(self):
        pat = re.compile("."*8)
        return bytes([int(i, 2) for i in pat.findall(self.data)])


class SCM_DF_Transmission_Payload(Enum):
    SCM_DF_Transmission_Payload_Tracking = 0


def scm_df_decode(hex_string):
    q = BitQueue(source=hex_string)
    data = OrderedDict()
    data['id'] = int(q.pop(4), 2)
    data['crc16'] = int(q.pop(16), 2)
    data['SF'] = int(q.pop(3), 2)
    data['MC'] = int(q.pop(9), 2)
    data['packet_type'] = SCM_DF_Transmission_Payload(int(q.pop(5)))
    if data['packet_type'] == SCM_DF_Transmission_Payload.SCM_DF_Transmission_Payload_Tracking:
        data['payload'] = OrderedDict()
        data['payload']['tracking'] = OrderedDict()
        data['payload']['tracking']['flags'] = int(q.pop(4), 2)
        data['payload']['tracking']['timeslot'] = int(q.pop(4), 2)
        data['payload']['tracking']['longitude'] = int(q.pop(22), 2)
        data['payload']['tracking']['latitude'] = int(q.pop(21), 2)
        data['payload']['tracking']['orientation'] = int(q.pop(3), 2)
        data['payload']['tracking']['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['battery'] = int(q.pop(5), 2)
        data['payload']['tracking']['temp_min'] = int(q.pop(6), 2)
        data['payload']['tracking']['temp_max'] = int(q.pop(6), 2)
        data['payload']['tracking']['temp_alert'] = int(q.pop(1), 2)
        data['payload']['tracking']['points'] = [OrderedDict(), OrderedDict(), OrderedDict()]
        data['payload']['tracking']['points'][0]['delta_km'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'][0]['delta_m'] = int(q.pop(7), 2)
        data['payload']['tracking']['points'][0]['delta_angle'] = int(q.pop(11), 2)
        data['payload']['tracking']['points'][0]['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['points'][0]['temp_alert'] = int(q.pop(1), 2)
        data['payload']['tracking']['points'][1]['delta_km'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'][1]['delta_m'] = int(q.pop(7), 2)
        data['payload']['tracking']['points'][1]['delta_angle'] = int(q.pop(11), 2)
        data['payload']['tracking']['points'][1]['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['points'][1]['temp_alert'] = int(q.pop(1), 2)
        data['payload']['tracking']['points'][2]['delta_km'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'][2]['delta_m'] = int(q.pop(7), 2)
        data['payload']['tracking']['points'][2]['delta_angle'] = int(q.pop(11), 2)
        data['payload']['tracking']['points'][2]['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['points'][2]['temp_alert'] = int(q.pop(1), 2)
    data['bch32'] = int(q.pop(32), 2)
    if q.size() != 0: raise DecodeError('Not all data decoded. {} bits remaining'.format(q.size()))
    return data


def scm_df_encode(data):
    q = BitQueue()
    q.push(data['id'], 4)
    q.push(data['crc16'], 16)
    q.push(data['SF'], 3)
    q.push(data['MC'], 9)
    q.push(data['packet_type'], 5)
    if data['packet_type'] == SCM_DF_Transmission_Payload.SCM_DF_Transmission_Payload_Tracking:
        q.push(data['payload']['tracking']['flags'], 4)
        q.push(data['payload']['tracking']['timeslot'], 4)
        q.push(data['payload']['tracking']['longitude'], 22)
        q.push(data['payload']['tracking']['latitude'], 21)
        q.push(data['payload']['tracking']['orientation'], 3)
        q.push(data['payload']['tracking']['activity'], 8)
        q.push(data['payload']['tracking']['battery'], 5)
        q.push(data['payload']['tracking']['temp_min'], 6)
        q.push(data['payload']['tracking']['temp_max'], 6)
        q.push(data['payload']['tracking']['temp_alert'], 1)
        q.push(data['payload']['tracking']['points'][0]['delta_km'], 6)
        q.push(data['payload']['tracking']['points'][0]['delta_m'], 7)
        q.push(data['payload']['tracking']['points'][0]['delta_angle'], 11)
        q.push(data['payload']['tracking']['points'][0]['activity'], 8)
        q.push(data['payload']['tracking']['points'][0]['temp_alert'], 1)
        q.push(data['payload']['tracking']['points'][1]['delta_km'], 6)
        q.push(data['payload']['tracking']['points'][1]['delta_m'], 7)
        q.push(data['payload']['tracking']['points'][1]['delta_angle'], 11)
        q.push(data['payload']['tracking']['points'][1]['activity'], 8)
        q.push(data['payload']['tracking']['points'][1]['temp_alert'], 1)
        q.push(data['payload']['tracking']['points'][2]['delta_km'], 6)
        q.push(data['payload']['tracking']['points'][2]['delta_m'], 7)
        q.push(data['payload']['tracking']['points'][2]['delta_angle'], 11)
        q.push(data['payload']['tracking']['points'][2]['activity'], 8)
        q.push(data['payload']['tracking']['points'][2]['temp_alert'], 1)
    q.push(data['bch32'], 32)
    result = q.get_bytes()
    if len(result) != SCM_DF_BUF_SIZE:
        raise EncodeError("Invalid Message Size: {}, should be {}".format(len(result), SCM_DF_BUF_SIZE))
    return result

