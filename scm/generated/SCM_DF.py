# SCM_Utils is a library of utilities for the Space Cows Project
# 
# MIT License
# 
# Copyright (c) 2023 eResearch Centre, James Cook University
# Author: Nigel Bajema
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

# This file has been automatically generated by BitPacker.
# DO NOT EDIT IT or your changes will be overwritten.

from enum import Enum
from collections import OrderedDict
from queue import Empty
import re


# SCM_DF Constants
SCM_DF_BUF_SIZE = 31
SCM_DF_TRANSMISSION_RECORDS = 4


class DecodeError(Exception): pass
class EncodeError(Exception): pass


class BitQueue:
    def __init__(self, source=""):
        self.source = source
        if source.startswith("0x") or source.startswith("0X"):
            self.source = source[2::]

        self.data = None
        self.reset()

    def reset(self):
        if len(self.source) == 0:
            self.data = ""
            return
        result = ""            
        data = bytes.fromhex(self.source)
        for i in data:
            result = "{}{}".format(result, bin(i)[2:].zfill(8))
        self.data = result

    def pop(self, count):
        if self.size() == 0: raise Empty()
        result = self.data[:count]
        self.data = self.data[count:]
        return result

    def size(self):
        return len(self.data)

    def clear(self):
        self.data = ""

    def __push(self, bits):
        symbols = {x:'' for x in bits}
        _valid_symbols = {k:v for k, v in symbols.items() if k in [0, 1, '0', '1']}
        if len(_valid_symbols.keys()) != len(symbols.keys()):
            raise Exception("Invalid Symbols")
        self.data = "{}{}".format(self.data, bits)
    
    def push(self, value, bits):
        if hasattr(value, '__dict__') and isinstance(value, Enum):
            value = value.value    
        v = bin(value & int('1'*bits, 2))[2:]
        self.__push(v.zfill(bits))
    
    def get_bytes(self):
        pat = re.compile("."*8)
        return bytes([int(i, 2) for i in pat.findall(self.data)])


class SCM_DF_Transmission_Payload(Enum):
    SCM_DF_Transmission_Payload_Tracking = 0
    SCM_DF_Transmission_Payload_Status = 1


def scm_df_decode(hex_string):
    q = BitQueue(source=hex_string)
    data = OrderedDict()
    data['id'] = int(q.pop(4), 2)
    data['crc16'] = int(q.pop(16), 2)
    data['SF'] = int(q.pop(3), 2)
    data['MC'] = int(q.pop(9), 2)
    data['packet_type'] = SCM_DF_Transmission_Payload(int(q.pop(5)))
    if data['packet_type'] == SCM_DF_Transmission_Payload.SCM_DF_Transmission_Payload_Tracking:
        data['payload'] = OrderedDict()
        data['payload']['tracking'] = OrderedDict()
        data['payload']['tracking']['flags'] = int(q.pop(5), 2)
        data['payload']['tracking']['timeslot'] = int(q.pop(4), 2)
        data['payload']['tracking']['longitude'] = int(q.pop(22), 2)
        data['payload']['tracking']['latitude'] = int(q.pop(21), 2)
        data['payload']['tracking']['orientation'] = int(q.pop(3), 2)
        data['payload']['tracking']['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['battery'] = int(q.pop(5), 2)
        data['payload']['tracking']['temp_min'] = int(q.pop(6), 2)
        data['payload']['tracking']['temp_max'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'] = [OrderedDict(), OrderedDict(), OrderedDict()]
        data['payload']['tracking']['points'][0]['delta_km'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'][0]['delta_m'] = int(q.pop(7), 2)
        data['payload']['tracking']['points'][0]['delta_angle'] = int(q.pop(11), 2)
        data['payload']['tracking']['points'][0]['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['points'][0]['temp'] = int(q.pop(1), 2)
        data['payload']['tracking']['points'][1]['delta_km'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'][1]['delta_m'] = int(q.pop(7), 2)
        data['payload']['tracking']['points'][1]['delta_angle'] = int(q.pop(11), 2)
        data['payload']['tracking']['points'][1]['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['points'][1]['temp'] = int(q.pop(1), 2)
        data['payload']['tracking']['points'][2]['delta_km'] = int(q.pop(6), 2)
        data['payload']['tracking']['points'][2]['delta_m'] = int(q.pop(7), 2)
        data['payload']['tracking']['points'][2]['delta_angle'] = int(q.pop(11), 2)
        data['payload']['tracking']['points'][2]['activity'] = int(q.pop(8), 2)
        data['payload']['tracking']['points'][2]['temp'] = int(q.pop(1), 2)
    if data['packet_type'] == SCM_DF_Transmission_Payload.SCM_DF_Transmission_Payload_Status:
        data['payload']['status'] = OrderedDict()
        data['payload']['status']['flags'] = int(q.pop(5), 2)
        data['payload']['status']['timeslot'] = int(q.pop(4), 2)
        data['payload']['status']['longitude'] = int(q.pop(22), 2)
        data['payload']['status']['latitude'] = int(q.pop(21), 2)
        data['payload']['status']['padding_0'] = int(q.pop(127), 2)
    data['bch32'] = int(q.pop(32), 2)
    if q.size() != 0: raise DecodeError('Not all data decoded. {} bits remaining'.format(q.size()))
    return data


def scm_df_encode(data):
    q = BitQueue()
    q.push(data['id'], 4)
    q.push(data['crc16'], 16)
    q.push(data['SF'], 3)
    q.push(data['MC'], 9)
    q.push(data['packet_type'], 5)
    if data['packet_type'] == SCM_DF_Transmission_Payload.SCM_DF_Transmission_Payload_Tracking:
        q.push(data['payload']['tracking']['flags'], 5)
        q.push(data['payload']['tracking']['timeslot'], 4)
        q.push(data['payload']['tracking']['longitude'], 22)
        q.push(data['payload']['tracking']['latitude'], 21)
        q.push(data['payload']['tracking']['orientation'], 3)
        q.push(data['payload']['tracking']['activity'], 8)
        q.push(data['payload']['tracking']['battery'], 5)
        q.push(data['payload']['tracking']['temp_min'], 6)
        q.push(data['payload']['tracking']['temp_max'], 6)
        q.push(data['payload']['tracking']['points'][0]['delta_km'], 6)
        q.push(data['payload']['tracking']['points'][0]['delta_m'], 7)
        q.push(data['payload']['tracking']['points'][0]['delta_angle'], 11)
        q.push(data['payload']['tracking']['points'][0]['activity'], 8)
        q.push(data['payload']['tracking']['points'][0]['temp'], 1)
        q.push(data['payload']['tracking']['points'][1]['delta_km'], 6)
        q.push(data['payload']['tracking']['points'][1]['delta_m'], 7)
        q.push(data['payload']['tracking']['points'][1]['delta_angle'], 11)
        q.push(data['payload']['tracking']['points'][1]['activity'], 8)
        q.push(data['payload']['tracking']['points'][1]['temp'], 1)
        q.push(data['payload']['tracking']['points'][2]['delta_km'], 6)
        q.push(data['payload']['tracking']['points'][2]['delta_m'], 7)
        q.push(data['payload']['tracking']['points'][2]['delta_angle'], 11)
        q.push(data['payload']['tracking']['points'][2]['activity'], 8)
        q.push(data['payload']['tracking']['points'][2]['temp'], 1)
    if data['packet_type'] == SCM_DF_Transmission_Payload.SCM_DF_Transmission_Payload_Status:
        q.push(data['payload']['status']['flags'], 5)
        q.push(data['payload']['status']['timeslot'], 4)
        q.push(data['payload']['status']['longitude'], 22)
        q.push(data['payload']['status']['latitude'], 21)
        q.push(0, 127)
    q.push(data['bch32'], 32)
    result = q.get_bytes()
    if len(result) != SCM_DF_BUF_SIZE:
        raise EncodeError("Invalid Message Size: {}, should be {}".format(len(result), SCM_DF_BUF_SIZE))
    return result

